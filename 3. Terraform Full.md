### What is Terraform? +
Open-source and cloud-agnostic and declarative Infrastructure as Code tool.
* It uses configuration files to declare the infrastructure and these files use HashiCorp Configuration Language (HCL).
![[Pasted image 20231130084430.png]]
### What are notable features of Terraform? +
* Installable modules.
* Plan and predict changes.
* Dependency graphing.
* State management.
* Provisioning infrastructure in familiar languages via AWS CDK.
* Terraform Registry with 1000+ providers.
### What is Terraform Cloud? +
Terraform Cloud is a SaaS product that offers unified portal for:
* Remote state storage
* Version Control integrations
* Flexible workflows
* Collaboration on Infrastructure changes
### Explain Terraform Lifecycle +
1. Code - Write or update your config file.
2. init - Initialise your project and pull modules/providers.
3. plan - Generate an execution plan.
4. validate - Ensure types and values are valid and required attributes are present.
5. apply - Execute the terraform plan provisioning the infrastructure.
6. (optional) destroy - Destroy the remote infrastructure.
![[Pasted image 20231130085121.png]]
### What is Change Management? +
Standard approach to apply change and resolve conflicts caused by change. In the context of IaC, Change management is the procedure that will be followed when resources are modified via the configuration script.
### What is Change Automation? +
A way of automatically creating a consistent, systematic and predictable way of managing change request via controls and policies.
### What form does Terraform implement Change Management and Change Automation? +
It uses Execution Plans and Resource Graphs to apply and review complex changesets.
### Explain Execution Plans +
Execution Plan - manual review of what will add/change/destroy before applying changes i.e. `terraform apply`.
![[Pasted image 20231130123255.png]]
### How to visualise Execution Plans in Terraform? +
`teraform graph` command can be used which will product a GraphViz file (GraphViz will be required to view the file).
![[Pasted image 20231130123401.png]]
### Explain Dependency/Resource Graph in Terraform +
Dependency graph is a graph data structure that Terraform generates and then traverses it to generate plans, refresh state and more.
* It is a directed graph that presents the dependencies between objects (in our case Infrastructure).
![[Pasted image 20231130123700.png]]
### What are some Use Cases of Terraform? +
* Exotic providers - has loads of providers for different services such as Spotify, Heroku, Alibaba etc.
* Multi-Tier Applications - Terraform makes it easy to divide large and complex applications into isolated configuration scripts (modules).
* Disposable Environments - easy to stand-up an environment for demos or ephemeral environments.
* Resource Schedulers - Terraform is not just defined to infrastructure of cloud resource but can also be used to schedule Docker containers, Spark, Hadoop clusters, etc. You can provision your own scheduling grid.
* **Multi-Cloud Deployments (VERY IMPORTANT)** - Terraform is cloud-agnostic and allows a single configuration to be used to manage multiple providers and to even handle cross-cloud dependencies.

### Explain Terraform Core and Plugins +
Terraform consists of two parts:
1. Terraform Core - uses RPC to communicate with Terraform Plugins
2. Terraform Plugins - exposes an implementation for a specific service or provisioner.
![[Pasted image 20231130125608.png]]
It's written in Golang!
### Explain Terraform Provisioners +
Terraform Provisioners - install software, edits files and provisioned machines created with Terraform.
* There are two types of provisioners.
	1. Cloud-Init - industry standard across Cloud Providers to have an input box to put YAML or bash scripts e.g. AWS EC2 User Data.
	2. HashiCorp Packer - automated image-builder service. You provide a config file and provision the machine to create a Machine Image to store in a repository for future use.
Provisioners should only be used as a last resort. For most common cases there are better alternatives.
### How is cloud-init set-up to work with Terraform? +
1. Create your own Cloud-Init script.
2. Define it in the template file.
![[Pasted image 20231130131929.png]]

### Does Terraform support 3rd party tools such as Chef, Puppet, Salt? +
* Direct support for these tools has been deprecated for Terraform, however it can still be used via Cloud-Init.
	* It may work with Ansible as it is a more complex tool.
![[Pasted image 20231130132032.png]]
### Explain "local-exec" Provisioner +
* local-exec allows you to execute local commands after a resource is provisioned.
![[Pasted image 20231130132145.png]]
![[Pasted image 20231130132652.png]]
### What are the use cases of local-exec? +
Example: After a VM is provisioned it needs to get a 3rd party IP address for a service which is exposes via a CLI call. Local-Exec can be used to execute the commands to get that IP.
### What is the difference between local-exec and Terraform Outputs? +
* Terraform outputs allow you to output results after running `terraform apply`.
* local-exec allows you to run any arbitrary commands on your local machine. Commonly used to trigger Configuration Management such as Ansible, Chef, Puppet, etc.
### What are some of the parameters of local-exec Provisioner? +
* command - command you want to execute
* working_dir - where the command will be executed (on the machine)
* interpreter - the entrypoint for the comment e.g. bash, ruby, aws cli, powershell, etc
* environment - key-value pairs of environment variables
### Explain remote-exec Provisioner +
`remote-exec` allows you to execute commands on the target machine **after** a resource is provisioned. It's useful for provisioning VMs with a simple set of commands.
* For more complex tasks use Cloud-Init or build a Golden Image.
![[Pasted image 20231130133049.png]]
![[Pasted image 20231130133109.png]]
### What modes of execution does of remote-exec Provisioner have? +
Only one mode can be used at a time
* inline - list of command strings.
* script - relative or absolute path to a script that will be copied and be executed.
* scripts - list of relative or absolute paths to local scripts that will be copied to remote instance and executed.
![[Pasted image 20231130133429.png]]
![[Pasted image 20231130133440.png]]
### Explain file Provisioner +
`file` provisioner is used to copy files or directories from our local machine to the newly created resource.
* source - the local file we want to upload to the remote machine
* content - a file or a folder
* destination - where you want to upload the file on the remote machine.
This may require a connection block within the provisioner for authentication.
![[Pasted image 20231130135421.png]]
### Explain connection block +
connection block - tells the provisioner how to establish a connection to an instance.
![[Pasted image 20231130181940.png]]
### Can connection block be used to connect to a Bastion Host? +
Yes a SSH connection can be set up using the following parameters:
* bastion_host
* bastion_host_key
* bastion_port
* bastion_user
* bastion_password
* bastion_private_key
* bastion_certificate
### Explain null resources +
null_resource is a placeholder for resources that have no specific associate to provider resources. It's usually used trigger a re-run of a provisioner.
![[Pasted image 20231130182245.png]]
### Terraform Data +
It is a placeholder much like null_resource but it does not require **provider**. It is preferable over null_resource.
![[Pasted image 20231130182352.png]]

### Explain Providers +
Providers are Terraform plugins that allow you to interact with a service provider such as:
* Cloud Providers - AWS, GCP, Azure
* SaaS Providers - GitHub, Stripe, Checkly.
* Other APIs: Kubernetes, Postgres.
They are essentially plugins that map to the APIs of the service provider.
### What tiers of Providers are there in Terraform? +
* Official - published by the company that owns the service
* Verified - actively updated, and compatible with both Terraform and the service provider
* Community - published by a community member but no guarantee of maintenance or compatibility.
### When are Providers loaded? +
* When running `terraform init` as they're distributed separately from Terraform.
### Explain Terraform Registry +
Terraform Registry is a website portal to browse, download and publish **Providers or Modules**.
* Everything published on Terraform Registry is **public-facing**. Basically like Docker Hub but for Terraform.
### What kind of Plugins are there? +
* Providers - mappings to the API of the service provider e.g. AWS.
* Module - group of configuration files that provide a common configuration functionality.
	* Enforces best practices
	* Reduces amount of code
	* Improve development speed
### Explain Private Registry +
Private Registry is a Private version of the Terraform Registry that is offered by the Terraform Cloud service. When creating a module it is necessary to link the Git repository to the registry.
### How to get the list of providers used at a time? +
`terraform providers`
![[Pasted image 20231130184157.png]]

### How to set-up two separate Providers for the same service? +
1. Create an alternative provider using an alias.
2. Reference the alias provider in your resources you're provisioning.
![[Pasted image 20231130184344.png]]
### Explain Terraform Modules +
Terraform Module is a group of configuration files that provide common configuration.
* Enforces best practices
* Reduces the amount of code
* Improves development speed.
Example: provisioning a AWS VPC can be done in a single block.
![[Pasted image 20231130184611.png]]
### Explain The Fine Line in Terraform +
The Fine Line is understanding the granularities of responsibility between Terraform Infrastructure and 3rd Party Configuration Management.

Example: when you have a Postgres Database which is the a atypical resource compared to a cloud service like an S3. Who should automate what?
![[Pasted image 20231130184904.png]]
### Explain HashiCorp Configuration Files (aka Terraform Files) +
Terraform Files contain the configuration of providers and resources. They end with `.tf` or `.tf.json` suffix and use Terraform Language based on  HashiCorp Configuration Language (HCL).
![[Pasted image 20231130185125.png]]
### Explain Alternate JSON Syntax of Terraform Language +
Terraform also supports alternative JSON syntax by having the config files end with `.tf.json` suffix. It's useful when portions of configuration are created programmatically since JSON libraries can be used to create the config file.
![[Pasted image 20231130185325.png]]
### Explain Terraform Settings +
Terraform Settings is a terraform configuration block type where Terraform itself is configured.
![[Pasted image 20231130185427.png]]
### Explain HashiCorp Configuration Language (HCL) +
HCL is an open-source toolkit for creating structured configuration languages that are both and machine friendly. It is a base-language that can be extended for custom use cases.
![[Pasted image 20231130185542.png]]
### Explain Input Variables +
Input Variables (aka variables for Terraform Variables) are parameters for Terraform modules. They are defined via variable blocks.
![[Pasted image 20231130185741.png]]
Input variables have these parameters
default, type, description - self-explanatory.
validation - list of validation rules.
sensitive - hides the value when Terraform outputs are shown.
### Explain Variable Definition Files
Files that allow you to set the values for multiple variables at once. They have a suffix of `.tfvars` or `.tfvars.json`
* By default `terraform.tfvars` will be autoloaded when included into the root of your project directory.
![[Pasted image 20231130190107.png]]
### Explain how Terraform can use environment variables
* Terraform can also read off the environment of the machine that runs it. These variables need to have the TF_VAR_* prefix to them e.g. TF_VAR_image_id which will then be loaded as "image_id".
![[Pasted image 20231130191143.png]]

### What are the ways of loading Terraform input variables?
1. Default autoloaded variables file `terraform.tfvars`.
2. Additional variable files `filename.tfvars`. These are not autoloaded and will have to be specified in the command line (can be used for segregate vars by env e.g. `dev.tfvars`, `staging.tfvars`, `prod.tfvars`).
	1. Loaded via `-var-file dev.tfvars` command.
3. Additional variable files (autoloaded) such as `filename.auto.tfvars`.
4. Inline variables via command line `-var ec2_type="t2.micro"`.
5. Environment variables `TF_VAR_variable_name` - common in CI.
### What is the variable precedence?
Precedence - the priority at which the files will override each other:
1. -var and -var-file
2. .auto.tfvars or .auto.tfvars.json
3. terraform.tfvars.json
4. terraform.tfvars
5. Environment variables
### Explain output values
Output values are computed values after a `terraform apply` is performed. They can be used to:
* obtain information about resource provisioned e.g. public IP address
* output file of values for programmatic integration
* Cross-reference stacks via outputs in a state file via `terraform_remote_state`.
![[Pasted image 20231130194830.png]]
### How to print all of the outputs for a state file?
* `terraform outputs` for all
* `terraform outputs <name>` - specific
* `terraform outputs -json` - outputs everything as JSON
* `terraform outputs -raw` - preserves quotes for strings
### Explain Locals (Local Values)
Locals assign a name to an expression you can use it multiple times within a module without repeating it.
![[Pasted image 20231130195151.png]]
### How to reference a local value?
![[Pasted image 20231130195209.png]]
* Locals should be used sparingly since Terraform is intended to be declarative and overuse of locals makes it hard to determine what the code is doing.
### Explain Data Sources
Data sources is a block that allows to use information defined outside of Terraform defined by separate Terraform configuration or modified by functions.
![[Pasted image 20231130201036.png]]
### Explain Named Values
Named values are built-in expressions to reference various values such as:
* Resources => `<ResourceType><Name>` e.g. `aws_instance.my_server`.
* Input variables => `var.<Name>` 
* Local variables => `local.<Name>`
* Module outputs => `module.<Name>`
* Data sources => `data.<DataType>.<Name>`

Filesystem and workspace info:
* `path.module` - path of the module where the expression is placed.
* `path.root` - path of the root module of the configuration.
* `path.cwd` - path of the current working directory.
* `terraform.workspace` - name of the currently selected workspace.

Block-local values (within body of blocks)
`count.index` - when you use the count meta argument.
`each.key` / `each.value` - when you use the `for_each` meta argument.
`self.<attribute>` = self reference information within the block (provisioners and connections)
### Explain Resource Meta-Arguments
Terraform language defines several meta-arguments which can be used with any resource type to change the behaviour of resources.
* `depends_on` - specifying explicit dependency.
* `count` - creating multiples of the same resource.
* `for_each` to create multiple instances according to a map or list of strings.
* `lifecycle` - for lifecycle customisations.
* `provisioner` and `connection` for taking extra actions after resource creation.
### Explain "depends_on" meta argument
Terraform can imply the order of resource creation but in some cases it can not, in such cases `depends_on` flag can be used.
![[Pasted image 20231130203724.png]]
### Explain "count" meta argument
Useful when managing a pool of objects e.g. a fleet of VMs.
* The values are zero-indexes (start at 0) and must be integers (whole).
![[Pasted image 20231130203807.png]]
### Explain "for_each" meta argument
Similar to count but instead of specifying an integer, we are providing a list or a map to iterate through. These values can then be used to dynamically generate resources.
![[Pasted image 20231130204051.png]]
### Explain Resource Behaviour
When `terraform apply`is executed it will perform one of the following commands:
* Create - resources that are not associated with real infrastructure object in the state.
* Destroy - resources that exist in the state but no longer exist in the configuration.
* Update in-place - update resources whose arguments have changed
* Destroy and re-create - resources whose arguments have changed but which can not be updated in-place due to API limitations.
![[Pasted image 20231130204711.png]]
### Explain Lifecycle Blocks
Lifecycle blocks allows us to change what happens to a resource e.g. create, update, destroy.
* Lifecycle blocks are nested within resources.

Here are some values for the lifecycle block:
* `create_before_destroy (bool)` - when replacing a resource it will create the new resource before destroying the current one.
* `prevent_destroy (bool)`` - ensures the resource is NOT destroyed
* `ignore_changes (list of attributes)` - don't change the resource (create, update destroy), the resource if a change occurs for the listed attributes.
### Explain Resource Providers and Alias +
Used to override the default provider (of a specific service) and have two separate providers for the same infrastructure/saas provider.
![[Pasted image 20231130205132.png]]
### Explain Terraform Expressions +
Terraform expressions are used to **refer to** or **compute values** within a configuration.
### What types does Terraform support? +
**Primitive types:**
string => `ami = "ami-123"`
number => `size = 6.21231245`,
bool => `termination_protection = true`

**No type:**
null => `endpoint = null`
* `null` represents absence or omission.

**complex/structural/collection types:**
* list (tuple) - `regions = ["eu-west-2", "eu-west-1"]`
* map (object) - `tags = { env = "prod", priority = 3 }`
### Explain "String" type in Terraform
When using strings "double quotes" are used e.g. `"hello"`.
* Double quotes allow escape sequences:
![[Pasted image 20231130205738.png]]
Terraform also supports a "heredoc" style (heredoc is a UNIX-style multi-line string):
![[Pasted image 20231130205809.png]]
### Explain "String Templates"
`String Templates (interpolation)` allows us to evaluate an expression between marker `${...}` and converts it into a string.
* String directive - allows us to evaluate conditional logic between the markers `%{ ... }`
![[Pasted image 20231130210425.png]]
### What mathematical operators does Terraform have?
Terraform supports most operators that conventional programming languages support.
![[Pasted image 20231130210455.png]]
### Explain "Conditional Expressions"
Conditional Expressions allows us to do `if/else` statements in a `ternary` style.
* Both values `(true/false)` for the conditional expression must be of same type.
![[Pasted image 20231130210643.png]]
![[Pasted image 20231130210650.png]]
### Explain "For Expressions"
For expressions allows us to iterate over a complex type and apply transformations
* A for expression can accept as input only a `list, set, tuple, map or object`.
	* They're very similar to list comprehension in Python.
![[Pasted image 20231130211356.png]]
![[Pasted image 20231130211425.png]]
### Explain Splat Expressions
Splat Expressions are shortened version of for expression. It uses the splat operator `* (asterisk)` which originates from ruby.
![[Pasted image 20231201065833.png]]
### What special behaviour does Splat Expressions have when applied to lists?
* If the value is anything other than null, then plat will transform it into a single-element list.
* If value is null then splat will return an empty tuple.
### Explain Dynamic Blocks
Dynamic blocks allows us to dynamically construct repeatable nested blocks. It's a very powerful feature but can be abused leading to too much abstraction.
![[Pasted image 20231201070502.png]]
### Explain Version Constraints
* Terraform utilises **Semantic Versioning** for specifying the versions of Terraform and its' Plugins (Providers, Modules).
	* **Semantic Versioning** is an open-standard on how define software versions e.g. `MAJOR.MINOR.PATCH`.
**Version Constraint** is a string containing one or more conditions, separated by commas.
![[Pasted image 20231201070721.png]]
### Explain Progressive Versioning
Progressive Versioning is the practice of using the latest version to keep a proactive stance on security, modernity and development agility.
 * This forces us to push small updates often resulting in many tiny problems instead of one gigantic one.

Running **nightly** builds is a good with a warning signal attached is a good way of tracking if everything is compatible.
### Explain Terraform State
Terraform State - particular condition of cloud resources at a specific time e.g. we expect there to be a VM running CentOS on AWS with a compute type of t2.micro.
### How does Terraform preserve state?
When you provision infrastructure via Terraform it will create a state file named `terraform.tfstate`. This is a JSON data structure with one-to-one mapping from resource instances and remote objects.
![[Pasted image 20231201072053.png]]
### What CLI commands are there for Terraform state?
`terraform state list` - list resources in the state
`terraform state mv` - move an item in the state
`terraform state pull` - pull current remote state and output to stdout
`terraform state push` - update remote state from local state
`terraform state replace-provider` - replace provider in the state
`terraform state rm` - remove instances from state
`terraform state show` - show a resource in state
### Explain `terraform state mv` command
`terraform state mv - (move)` - allows us to:
* rename existing resources
* move a resource into a module
* move a module into a module.
 ![[Pasted image 20231201072421.png]]
### Explain Terraform state backups + 
All terraform state subcommands that **modify state** will write a backup file.
* This file is stored as `terraform.tfstate.backup`.
Backup files can not be disabled as they're a best practice and can only be deleted manually.
### Explain `terraform init`
`terraform init` - command that initialises a terraform projet by:
* Downloading plugin dependencies (providers and modules).
* Creates the `.terraform` directory
* Creates a dependency lock file to enforce expected versions for plugins and terraform itself.

Every time the dependencies are modified or changed `terraform init` needs to be ran again to apply the changes.

**Some flags:**
`terraform init -upgrade` - upgrades all plugins to the latest version so it complies with configuration's version constraint.
`terraform init -get-plugins-false` - skips plugin installation.
`terraform init -plugin-dir=PATH` - force plugin installation and reading from a specific directory.
`terraform init --lockfile=MODE` - set a dependency lockfile mode.
### Explain `terraform get`
`terraform get` - command is used to download and **update** modules in the root module.
* Useful when downloading everything without initialising a state file.
### Explain `terraform fmt`
`terraform fmt` - rewrites Terraform configuration files to a standard format and style.
* It will apply Terraform language style conventions along with minor adjustments to readability.
	* `--diff` flag can be used to check what *would* be changed.
![[Pasted image 20231201073947.png]]
### Explain `terraform validate`
`terraform validate` - verifies whether a configuration is syntactically valid and internally consistent, regardless of any provided variables for existing state. Useful for general validation of reusable modules.
![[Pasted image 20231201074131.png]]
* `terraform validate` is ran as part of `terraform plan` and `terraform apply`.
### Explain `terraform console`
`terraform console` - interactive shell for evaluating Terraform expressions.
![[Pasted image 20231201074817.png]]
### Explain `terraform plan`
`terraform plan` create an execution plan (aka Terraform plan). A plan consists of:
* Reading the current state of any already-existing remote objects to make sure the Terraform state is up-to-date.
* Compare the current configuration to the prior state and noting any differences
* Proposing a set of change actions that should, if applied make the remote objects match the configuration.

Plans can be written out into a file as shown below
![[Pasted image 20231201075013.png]]
Terraform DOES NOT carry out the proposed changes.
### Explain `terraform apply`
Executes the actions proposed in an execution plan that was created as part of `terraform plan`.
* `-auto-approve` flag can be used to automatically approve the plan.
![[Pasted image 20231201075155.png]]
### Explain Resource Drift
`Resource Drift` - when our expected resources are in a different state than the expected state.
### What are the ways to resolve resource drift? 
1. Replacing Resources - `terraform apply --replace` to replace damaged or degraded resources that can not be detected by terraform 
2. Importing Resources - usually is done after an approved addition of resource(s) needs to be added to our state file.
3. Refreshing State - when approved manual configuration of a resource is no longer needed.
### Explain how Terraform replaces resources that have drifted
`terraform taint` can be used to **mark** resources for replacement, next time `terraform apply` is ran.
* It should be used when a cloud resource is degraded or damaged and you want to return it to the original state.
![[Pasted image 20231201102152.png]]

**As of v0.152 `terraform taint` is deprecated.** Use `terraform apply/plan` with the `-replace` flag.
![[Pasted image 20231201081843.png]]
### Explain Resource Addressing +
`Resource Address` is a string that **identifies zero or more resource instances** in your configuration.
![[Pasted image 20231201102352.png]]
### Explain `terraform import`
`terraform import` is a command used to import **existing** resources into Terraform. Here are the steps to import a resource into Terraform:
1. Define a placeholder for your imported resource in a configuration file (leave the body blank initially).
2. Run the import command `terraform import <RESOURCE_ADDRESS> <RESOURCE_TO_IMPORT_ID>` e.g. `terraform import aws_instance.example i-abcd1234`.
3. Update the placeholder with the configuration of the resource imported.
![[Pasted image 20231201102740.png]]
### Explain `terraform refresh`
`teroraform refresh` - reads the **current** settings from all managed remote objects and updates the Terraform state to match. **`terraform refresh` will NOT modify real remote objects, but will modify the Terraform state.**.

It has been deprecated and replaced with a `terraform apply` with a `-refresh-only` flag.
![[Pasted image 20231201102935.png]]
### Explain `Refresh-Only` Mode
Refresh-Only mode is ran via the `-refresh-only` flag. It is useful to resolve issues when infrastructure was **intentionally re-configured or deleted manually** and we need to update the Terraform state to match that.
![[Pasted image 20231201103248.png]]
### What types of errors can Terraform throw?
1. Language errors - syntax errors in the configuration
	* `terraform fmt, terraform validate, terraform version` can be used to fix this.
2. State errors - resource state has changed from the expected state in your config file.
	* `terraform refresh, terraform apply, terraform --replace`.
3. Core errors - a bug has occurred in the core library
	* Inspect `TF_LOG` or Open Github Issue to fix it
4. Provider errors - provider's API has changed and does not work.
	* Inspect `TF_LOG` or Open Github Issue to fix it.
### How to enable debug logs in Terraform?
It can be done by setting the `TF_LOG` environment variable
* `TF_LOG_CORE` can be set for only core logs.
* `TF_LOG_PROVIDER` can be set only for provider logs.

Here are possible values for `TF_LOG` and its' derivatives:
![[Pasted image 20231201103904.png]]
Here's an example of Terraform Logs:
![[Pasted image 20231201103932.png]]
### Explain Terraform Crash Log
If Terraform ever crashes (panics in **Golang**), it saves a logfile with the debug logs from the session as well as the panic message.
![[Pasted image 20231201104039.png]]
### What modules are displayed when searching for modules in Terraform Registry? +
* Only **Official** and **Verified**.

### What kind of Terraform Modules are there?
**Public**  -  directly integrated into Terraform and easily specified within the configuration files. After running `terraform init` they'll be downloaded.
![[Pasted image 20231201104526.png]]

**Private** - privately stored in Terraform Cloud and accessed via `<HOSTNAME>/<NAMESPACE>/<NAME>/<PROVIDER>` namespace. This also requires authentication using the `terraform login` command or an access token.
![[Pasted image 20231201104650.png]]
### How to Publish modules to Terraform Registry?
Public modules are stored in a public GitHub repository.
* Repo names must be in the format of `terraform-provider-name`.
![[Pasted image 20231201105919.png]]
* The existing repository can then be connected to Terraform Registry.
### What features do Published modules support?
* Versioning and browsing of old versions.
* Automatically generated docs, examples and READMEs.
### Explain Verified Modules
`Verified Modules` - **public** modules that are reviewed by HashiCorp and are actively maintained by the contributors and HashiCorp partners.
* Verified modules **DO NOT** guarantee flexibility and new feature support.
* **Unverified** modules **DO NOT** guarantee bad quality too.
![[Pasted image 20231201110204.png]]
### What is a Module Structure?
![[Pasted image 20231201110331.png]]
Primary entry point into the module is the `main.tf` at the root.
* `variables.tf` - variables that can be passed in.
* `outputs.tf` - output-ed values.
* `README.md` - describes how module works.
* `LICENSE.md` - license under which module is available.
### Explain nested modules
![[Pasted image 20231201110331.png]]
Submodules are optional parts of a module and are stored in the `modules/` directory.
* A submodule that has no `README` is considered internal-only.
* A submodule that has a `README` is usable by external users.
* Avoid using relative paths when source module blocks.
### Explain Core Terraform Workflow
`Core Terraform Workflows` are: 
**Write** - create infrastructure as code
**Plan** - preview changes before applying
**Apply** - provision reproducible infrastructure
![[Pasted image 20231201110933.png]]
**Workflow will change based on the team structure and size.**
### What kind of Terraform Workflow would an Individual Practitioner (One Person team) use?
![[Pasted image 20231201111506.png]]
### What kind of Terraform Workflow would an Team use (no Terraform Cloud)?
![[Pasted image 20231201111548.png]]
*  Additional considerations:
	* Cost that will go up as multiple environments are managed.
	* Safe and private injection of secrets.
	* Limiting access to the cloud environment.
	* Where/how to store the Terraform Backend.
### What kind of Terraform Workflow would be with Terraform Cloud? +
![[Pasted image 20231201115037.png]]
Terraform Cloud will streamline a lot of the CI/CD:
* Storing and securing sensitive variables.
* Makes it easy to go through and audit the run history.
### Explain Terraform Backends 
`Terraform Backend` - piece of configuration that defines where the Terraform operations are performed and where state snapshots are stored.
### What types of Terraform Backends are there?
**Standard backends**:
* Only stores the Terraform state.
* Does not perform operations:
	* Operations need to be performed via the CLI on your local machine.
* They are 3rd party backends such as AWS S3 bucket.

**Enhanced backends:**
* Can both store state and perform operations.
* Can be subdivided further:
	* `local` - files and data are stored on the local machine executing terraform commands.
	* `remote` - files and data are stored in the cloud e.g. Terraform Cloud.
### Explain Standard Backends
* Standard Backends are 3rd party providers that store state and perform no operations. Some examples are:
![[Pasted image 20231201120221.png]]
### How would you set up a backend using AWS S3?
![[Pasted image 20231201122622.png]]
### Explain Local Backends (CONTINUE HERE)
**Local Backend** is a machine that stores the Terraform state in the local filesystem and executes the operations. It can perform locking using file system API.
![[Pasted image 20231201122919.png]]
![[Pasted image 20231201122929.png]]
![[Pasted image 20231201122941.png]]
### Explain Remote Backends
A remote back-end uses a Terraform Platform:
* Terraform Cloud
* Terraform Enterprise
With a remote backend terraform is applied via the CLI inside the **Terraform Cloud Run Environment**.
![[Pasted image 20231201125255.png]]
### How to set up a Terraform Cloud Workspace when using a Remote Backend?
![[Pasted image 20231201125352.png]]
### What block should be used to set up remote backend when Terraform Cloud is used?
Previously `backend` block could be used, however now `cloud` block is the recommended way of doing it. **Both works!**
![[Pasted image 20231201125551.png]]
### Explain `-backend-config` flag for `terraform init`.
`-backend-config` flagis used for partial backend configuration. It is useful when the backend settings are dynamic or sensitive and can not be statically specified in the configuration file.
![[Pasted image 20231201125818.png]]
### Explain `terraform_remote_state`
`terraform_remote_state` is a data source that retrieves the root module output values from another Terraform configuration using the latest state snapshot from the remote backend. It's a way of getting data from a different Terraform configuration.
* Only root-level output values are exposed, data from nested modules is NOT.
![[Pasted image 20231201130113.png]]
### How to make nested module values accessible when using `terraform_remote_state`?
To make a nested module output value accessible as a root module output value, you must explicitly configure a passthrough in the root module.
![[Pasted image 20231201130146.png]]
### Are there any safer alternatives to using `terraform_remote_state`?
* For external consumption it is better to publish the data into a separate location such as an S3 bucket and then use the `data` block to read the values from the bucket.
![[Pasted image 20231201130410.png]]
### Explain Terraform State Locking
`State Locking` - process where Terraform locks your state for all operations that could write into it. This prevents from potentially corrupting your state.
* `-lock` flag can be used to disable locking when a command runs.
![[Pasted image 20231201131100.png]]
### How to disable a Terraform state lock?
* Use `terraform force-unlock` command (not recommended).
	* For protection-sake it requires the unique lock id to execute:
		* `terraform force-unlock LOCK_ID_NUMBER`
### What are some potential side-effects of force-unlocking a locked state?
* If someone else is holding the lock it can result in multiple writers (which may corrupt the file).

### How to protect sensitive data in the Terraform state?
Terraform state file **can protect sensitive data** e.g. AWS Creds. This can be an attack vector for malicious actors.

**When using Local State**:
* Do not share the file with anyone.
* Do not commit it to a Git repository.

**Remote State with Terraform Cloud:**
* That state file is held in memory and is not persisted to disk.
* State file is encrypted at-rest and in-trasit.
* Terraform Enterprise provides in-depth audit logging for tamper evidence.

**Third-Party Remote State:**
* Carefully review backends capabilities to determine if it meets your security and compliance requirements. E.g. when using S3 ensure CloudTrail is enabled and the bucket is encrypted.
### Explain Terraform Ignore File `(.terraformignore)`
`Terraform Ignore File (.terraformignore)` defines which paths to ignore when uploading a directory to Terraform Cloud.
### What files are by default ignored `(if .terraformignore does not exist)` when uploading to Terraform Cloud?
* Git directories `.git/*`
* Terraform directories `.terraform/*`.
### Explain Resources in a Configuration file
`Resources` in a configuration file represent infrastructure objects e.g. VMs, DBs, Storage, etc.
* A resourcey type determines the kind of infrastructure object e.g. `"aws_instance"` is an AWS EC2 Instance.
### Explain Complex Types
`Complex Types` a type that groups multiple values into a single value. There are two categories of complex types:
* Collection types - List, Map, Set
* Structural Types - Tuple Object
![[Pasted image 20231201142957.png]]
![[Pasted image 20231201143623.png]]
### Explain Built-In functions in Terraform
`Build-in` function are functions that can be called within expressions to transform and combine values. There loads of types for these functions:
* Numeric functions
* String functions
* Collection functions
* Encoding functions
* Filesystem functions
* Date and Time functions
* Hash and Crypto functions
* IP Network functions
* Type Conversion functions
### Explain `abs` function
`abs(NUMBER)` - returns absolute value of the given number 
* `abs(0) => 0`
* `abs(23) => 23`
* `abs(-12.4) => 12.4`
### Explain `floor` function
`floor(NUMBER)` - rounds down the number
* `floor(4.9) => 4`
* `floor(5) => 5`
### Explain `log` function
`log(NUMBER, BASE)` - returns logarithm of a given value and a base `log(VALUE, BASE)`
* `log(50, 10) => 1.69897`
* `log(16,2) => 4`
### Explain `ceil` function
`ceil(NUMBER)` - rounds up the number
* `ceil(5) => 5`
* `ceil(4.1) => 5`
### Explain `min/max` functions
`min & max` - return min or max of all the input values given
### Explain `parseint` function
`parseint` - parses the integer from a provided string, if it's impossible to parse it will throw an error.
![[Pasted image 20231201145030.png]]
### Explain `pow` function
`pow(NUMBER, BASE)` - raises a number to a desired power
* `pow(2,3) => 8`
### Explain `signum` function
* `signum(NUMBER)` - determines if the number provided is `+ve` or `-ve`.
* `signum(-13) => -1`
* `signum(13) => 1`
### Explain `chomp` function
`chomp(STRING)` - removes newline characters at the end of a string.
![[Pasted image 20231201145921.png]]
### Explain `format` function
`format(STRING)` - produces a string by formatting a number of other values according to a specification string.
![[Pasted image 20231201150010.png]]
### Explain `formatlist` function
`formatlist(SPECIFICATION_STRING, LIST_OF_STRINGS)` - produces a list of strings by formatting a number of other values to a specification string.
![[Pasted image 20231201150211.png]]
### Explain `join` & `split` function
`join(JOINER, LIST_OF_STRINGS)` - produces a string by joining the list of strings based on a `JOINER` variable.
![[Pasted image 20231201151929.png]]
`split("SPLITTER, "STRING")` - produces a list of strings divided by the `SPLITTER`.
![[Pasted image 20231201152203.png]]
### Explain `lower/upper` function
`lower(STRING) & upper(STRING)` - converts string to lowercase/uppercase.
### Explain `regex` & `regexall` function
`regex(REGEX, STRING)` - returns matching strings to the regex.
`regexAll(REGEX, STRING)` - returns **all** matching strings.
### Explain `replace` function
`replace(STRING, "PART_OF_STRING_TO_REPLACE", "REPLACE_TO_STRING")` - replaces parts of the string with desired input.
### Explain `strrev` function
`strrev(STRING)` - reverses string.
### Explain `substr` function
`substr(STRING, START_IDX, END_IDX)` - creates substring from input string (like JS `.slice()`).
### Explain `trimprefix` & `trimsuffix` & `trimspace` functions
![[Pasted image 20231201152650.png]]
### Explain `alltrue` function
![[Pasted image 20231201155523.png]]
### Explain `anytrue` function
![[Pasted image 20231201155554.png]]
### Explain `chunklist` function ![[Pasted image 20231201155641.png]]
### Explain `coalesce` function
![[Pasted image 20231201155717.png]]
### Explain `compact` function
![[Pasted image 20231201161038.png]]
### Explain `concat` function
![[Pasted image 20231201161057.png]]
### Explain `contains` function
![[Pasted image 20231201161119.png]]
### Explain `distinct` function
![[Pasted image 20231201161136.png]]
### Explain `element` function
![[Pasted image 20231201161206.png]]
### Explain `index` function
![[Pasted image 20231201161228.png]]
### Explain `flatten` function
![[Pasted image 20231201161244.png]]
### Explain `keys` function
![[Pasted image 20231201161905.png]]
### Explain `length` function
![[Pasted image 20231201161938.png]]
### Explain `lookup` function
![[Pasted image 20231201162011.png]]
### Explain `matchkeys` function
![[Pasted image 20231201162037.png]]
### Explain `merge` function
![[Pasted image 20231201162100.png]]
### Explain `one` function
![[Pasted image 20231201162131.png]]
### Explain `range` function
![[Pasted image 20231201162152.png]]
### Explain `reverse` function
![[Pasted image 20231201162208.png]]
### Explain `setintersection` function
Takes in multiple sets and returns a set that containing elements that are in all sets (intersect).
![[Pasted image 20231201162301.png]]
### Explain `setproduct` function
Finds all possible combinations of given sets by computing the cartesian product
![[Pasted image 20231204100803.png]]
### Explain `setsubstract` function
Returns a new set containing the elements from the first set that are not present in the second set. In other words, it computes the relative complement of the first set in the second set.
![[Pasted image 20231204100906.png]]
### Explain `setunion` function
Computes the union of all sets provided.
![[Pasted image 20231204100941.png]]
### Explain `slice` function
Extracts some consecutive elements from a list (same as JS slice)
![[Pasted image 20231204101026.png]]
### Explain `sort` function
Takes a list of strings and returns a new list of those strings sorted alphabetically.
![[Pasted image 20231204101141.png]]
### Explain `sum` function
Takes a list of numbers and returns their sum
![[Pasted image 20231204101216.png]]
### Explain `transpose` function
Takes a map of lists of strings and swaps the keys and values to produce a new map of lists of strings
![[Pasted image 20231204101205.png]]
### Explain `values` function
Takes in a map and returns a list of values for that map
![[Pasted image 20231204101330.png]]
### Explain `zipmap` function
Constructs a map from a list of keys and corresponding list of values
![[Pasted image 20231204101415.png]]
### Explain `base64encode` and `base64decode` function
![[Pasted image 20231204101451.png]]
### What are some other decoding/encoding functions?
![[Pasted image 20231204101528.png]]
### Explain `abspath` function
Takes a string containing a filesystem path and converts it to an absolute path, if the path 
### Explain `dirname` function
Takes a string containing a path and removes the last portion from it
![[Pasted image 20231204102045.png]]
### Explain `pathexpand` function
Takes a filesystem path that begins with `~` and replaces the tilde with current user's home directory path.
![[Pasted image 20231204102153.png]]
### Explain `basename` function
Takes a string of containing filesystem path and removes all except the last portion.
![[Pasted image 20231204102205.png]]
### Explain `file` function
Reads the contents of a file at the given path and returns them as a string.
![[Pasted image 20231204102310.png]]
### Explain `fileexists` function
Determines whether a file exists.
![[Pasted image 20231204102259.png]]
### Explain `fileset` function
Enumerates a set of regular file names given a path and pattern.
![[Pasted image 20231204102346.png]]
### Explain `filebase64` function
Reads the contents of a file and returns them as a base64 encoded string.
![[Pasted image 20231204102415.png]]
### Explain `templatefile` function
Reads the file at the given path and renders its content as a template using a supplied set of template variables.
![[Pasted image 20231204102459.png]]
![[Pasted image 20231204102645.png]]
### Explain `formatdate` function
Used to format a date.
![[Pasted image 20231204102814.png]]
### Explain `timeadd` function
Adds a specified amount of time to a date provided.
![[Pasted image 20231204102844.png]]
### Explain `timestamp` function
Returns a UTC timestamp string in RFC 3339 format
![[Pasted image 20231204103016.png]]
### Explain `bcrypt` function
Generates hashes and cryptographic strings.
![[Pasted image 20231204103051.png]]
### What other crypto/hash functions are there in Terraform?
![[Pasted image 20231204103121.png]]
### Explain `cidrhost` function
Calculates a full host IP address for a given host number within a given IP network address prefix.
![[Pasted image 20231204103828.png]]
### Explain `cidrnetmask` function
Converts an IPv4 address prefix given in CIDR notation into a subnet mask address.
![[Pasted image 20231204103907.png]]
### Explain `cidrsubnet` function
Calculates a subnet address within given IP network address prefix.
![[Pasted image 20231204103938.png]]
### Explain `cidrsubnets` function
Calculates a sequence of consecutive IP address ranges within a particular CIDR prefix.
![[Pasted image 20231204103953.png]]
### Explain Type Conversion functions
![[Pasted image 20231204104058.png]]
### Explain `can` function
Evaluates a given expression and returns a boolean indicating whether the expression would produce an error.
![[Pasted image 20231204104151.png]]
### Explain `defaults` function
A specialised function intended for use with input variables whose type constraints are object types or collections of object types that include optional attributes.
### Explain `sensitive` and `nonsensitive` function
`sensitive` - takes any value and returns a copy of it marked so that terraform treats it as sensitive.
![[Pasted image 20231204104957.png]]
`nonsensitive` - takes a sensitive value and returns a copy of that value with sensitive marking removed.
![[Pasted image 20231204105006.png]]
### Explain Organisations/Workspaces/Teams and Runs in Terraform Cloud (CONTINUE HERE)
`Organization` - a collection of workspaces
`Workspace` - unique environment or a Terraform stack.
`Teams` - collection of users/team members (assigned to one or more workspaces).
`Runs` - a single run of terraform run-environment that is operating on an execution plan.
![[Pasted image 20231204105927.png]]
### What types of Terraform Cloud Run Workflows are there?
`Version Control Workflow` - Terraform Cloud is integrated with a specific branch in VS e.g. GitHub via Webhooks.
* When PR is raised plans are generated.
* When PR is merged plans are executed via a run in Terraform Cloud.

`CLI-driven Workflow` - runs are triggered by the user running terraform CLI commands e.g. `terraform apply` and `terraform plan`.

`API-driven` - workspaces are NOT associated with VCS instead a 3rd party tool or system will trigger runs via upload a configuration file via Terraform Cloud API.
* A **Configuration Version** is what is uploaded to Terraform Cloud.
### Explain Organization-Level Permissions
`Organization-Level Permissions` allows us to manage certain resources and settings across an organisation.
* Manage Policies - create, edit, delete organisations **Sentinel** policies.
* Manage Policy Overrides - override soft-mandatory policy checks.
* Manage Workspaces - create and administrate all workspaces within the organisation.
* Manage VCS Settings - set of VCS providers and SSH keys available within the organisation.
### Explain Organisation Owners
`Organisation Owners` - special role that has every available permission and some actions only available to owners:
* Publish private modules.
* Invite users to organisation.
* Manage team membership.
* View all secret teams.
* Manage organisation permissions, settings and billing.
* Delete organisation.
* Manage agent.
### Explain Workspace-Level Permissions
Workspace-Level Permissions - manage resources for a specific workspace.
### Explain General Workspace Permissions?
Granular permissions that are applied to the user via **custom workspace permissions**
* Read runs
* Queue runs
* Apply runs
* Lock/unlock workspaces
* Download sentinel mocks
* Read variables (READ ONLY)
* Read/write variables
* Read state outputs
* Read state versions
* Read/ write state versions.
### Explain Fixed Permission Sets
Premade permissions for quick assignment.
* Read
	* Read runs
	* Read variables
	* Read state versions
* Plan
	* Queue plans
	* Read variables
	* Read state versions
* Write
	* Apply runs
	* Lock and unlock workspaces
	* Download sentinel mocks
	* Read/write variables
	* Read/write state versions
### Explain Workspace Admins
`Workspace Admin` - special role that grants all permissions and some workspace-admin-only permissions such as:
* Read and write workspace settings
* Set or remove workspace permissions of any team
### Explain API Tokens
API Tokens - an alternative method of authenticating when using Terraform cloud.
### What types of API Tokens are there?
Organisation API Tokens
Team API Tokens
User API Tokens
### Explain Organisation API Tokens
* Provides permissions across the entire organisation.
* Each organisation can have one valid API token at a time.
* Only organisation owners can generate and revoke an organisation's token.
* Organisation tokens are designed for creating and configurating workspaces and teams.
	* Should not be used as all-purpose interface to Terraform Cloud.
### Explain Team API Tokens
* Allow access to the workspaces that the team has access to, without being tied to any specific user.
* Each team can have one valid API token at a time.
* Any member of the team can re-generate the token (previous token becomes invalid).
* Designed for performing API operations on workspaces.
* Same access level to the workspaces the team has access to.
### Explain User API Tokens
* Most flexible token type because they inherit the permissions from the user they are associated with.
* Could be a real user or machine user.
### Explain Private Registry (in more detail)
Private version of Terraform Registry used for private modules that are shared within an organisation. Supports:
* module versioning.
* searchable and filterable list of available modules.
* configuration designer
### How to authenticate when using Private Registry?
* Using `terraform login` command - this will fetch user token.
* Using Team API token or User API token
	* To use team token you'll need to manually set it in your terraform CLI config file.
### Explain Cost Estimation
Cost Estimation is a feature of Terraform Cloud that will display a monthly cost of resources provisioned alongside your runs.
* Available with Teams and Governance plans and above.
![[Pasted image 20231204123413.png]]
* Sentinel Policies can be used to assert the expectation that resource are under particular cost.
* **Cost Estimation is relatively limited in terms of specific cloud resources it tracks.**
### Explain Workflow Options
Workflow Options - settings that can be configured for a Workspace.
1. Choose the version of Terraform for a workspace.
2. Toggle if Terraform state can be shared globally across the organisation.
3. Toggle if auto-approval is enabled or not.
![[Pasted image 20231204123922.png]]
### How to migrate local state into Terraform Cloud?
1. Create a workspace in Terraform Cloud
2. Replace your Terraform configuration with a remote back-end.
3. Run `terraform init`.
![[Pasted image 20231204124302.png]]
### Explain VCS Integration in Terraform Cloud
Terraform Cloud supports most of the Version Control System (VCS) providers:
* GitHub (OAuth & Enterprise)
* GitLab (EE and CE)
* BitBucket (Cloud, Server and Data Centre)
* Azure DevOps (Service and Server)
![[Pasted image 20231204124515.png]]
### Explain Terraform Run Environment
Run Environment - VM or Container that is intended for Terraform code execution for a specific runtime environment. **TLDR: Basically Terraform build server.**
![[Pasted image 20231204124628.png]]
### What environment variables are available in the Terraform Run Environment?
![[Pasted image 20231204124658.png]]
### Explain Terraform Cloud Agents
`Terraform Cloud Agents` - paid feature of the business plan that allows Terraform Cloud to communicate with isolated, private or on-prem infrastructure.
* Useful for on-prem infrastructure types such as vSphere, Nutanix or OpenStack.
* Agents support Terraform versions above 0.12
### What is required to run a Terraform Cloud Agent?
* x86_64 bit Linux OS.
	* Alternatively can be run as a Docker container.
* At least 4GB of free disk space and 2GB RAM.
* Access to make outbound requests on HTTPS (TCP Port 443) to:
	* app.terraform.io
	* registry.terraform.io
	* releases.hashicorp.com
	* archivist.terraform.io
### How does Terraform Cloud Agent communicate with Terraform Cloud?
The agent will poll Terraform Cloud for work and carry out execution of that work locally.
* TLDR: it is pull-based, therefore no inbound connections are required.
### Explain Terraform Enterprise
Terraform Enterprise - self-hosted distribution of Terraform Platform which offers a private instance of Terraform Platform application with benefits such as:
* No resource limits
* Additional enterprise-grade architectural features
	* Audit logging
	* SAML Single Sign-On (SSO)
![[Pasted image 20231204142729.png]]
### What operational modes are there for Terraform Enterprise?
* Operational mode - how data is stored?
	* External Services - S3, GCS, Azure Blob Storage, etc.
	* Mounted disk - stores data in a separate directory on the host for an external disk e.g. EBS.
	* Demo - stores all data on the instance but need backups (not recommended for production).
### What are the requirements Terraform Enterprise?
* 10 GB disk space in root directory and 40GB for Docker data.
* 4 CPU Cores & 8 GB RAM.
### Explain Air-Gapped Environments
Air-Gap - network security measure where one or more computers are physically isolated from unsecure networks e.g. public internet.
![[Pasted image 20231204143353.png]]
* Used in government, military or large enterprise (finance, energy, etc).
### Does Terraform Enterprise support Air-Gapped environments?
* Yes, Terraform Enterprise has an installation type for Air-Gapped environments. It is done via the Terraform Enterprise bundle that is provided by HashiCorp.
### How does Terraform Features are priced?
* Terraform itself is open-source and therefore is free.
* Terraform Cloud (Free Tier) - $0 up to 5 users
	* Has VCS integration, workspace management, remote runs, private registry, secure variable storage
* Terraform Cloud is - Starting at $20 user/month.
	* Adds team management, sentinel policy as code, cost estimation
* Terraform Enterprise - contracts are negotiated.
	* Adds SSO, Audit logging, self-hosted agents, configuration designer, ServiceNow integrations.
### Explain Workspaces
`Workspaces` - allows us to manage multiple environments or alternate state files e.g. Development & Production.
* There are two types of workspaces:
	* CLI Workspaces - a way of managing alternate state files (locally or via remote backends)
	* Terraform Cloud Workspaces - acts like completely separate working directories.

By default you have a single workspace in your local backend called default.
![[Pasted image 20231204144900.png]]
### What are the difference between local state and remote state when using a Workspace?
![[Pasted image 20231204145133.png]]
### How String Interpolation and conditionals be used with Current Workspace variable?
The current workspace can be used in  string interpolation via the `terraform.workspace` variable.
![[Pasted image 20231204145430.png]]
### Explain Terraform Cloud Run Triggers
`Run Triggers` - allows urns to queue automatically within a workspace on successful apply of runs in any of the source workspaces.
* They are designed for workspaces that rely on information produced by another workspace.
### What are some Terraform Workspace CLI commands?
![[Pasted image 20231204145810.png]]
### How does Workspaces differ between local workspace and Terraform Cloud?
![[Pasted image 20231204150144.png]]